1. 다음 중, 옳은 설명을 모두 고르세요.

List 인터페이스는 Collection 인터페이스의 하위(자식) 인터페이스이다.  o
List는 일반적으로 순서를 유지하지 않는다. x
 - 순서 유지
List는 중복된 요소를 허용한다. o
List는 요소의 삽입 위치를 선택할 수 없다. x
 - add()사용하면 가능
List 인터페이스는 동기화된 연산을 제공한다. x

2. 다음 중, 옳은 설명을 모두 고르세요.

Set 인터페이스는 Collection 인터페이스의 하위(자식) 인터페이스이다. o
Set은 일반적으로 순서를 유지한다. x
 - LinkedHashSet을 사용해야 유지할 수 있다.
Set은 중복된 요소를 허용하지 않는다. x
Set은 모든 요소가 유일하게 유지되어야 한다는 것을 제외하면 List 인터페이스와 마찬가지로 작동한다. o
Set 인터페이스는 동기화된 연산을 제공한다. x

3. 다음 중, 옳은 설명을 모두 고르세요.

Map 인터페이스는 Collection 인터페이스의 하위(자식) 인터페이스이다. x
 - Map은 상속받지 않는 인터페이스이다.
Map은 키-값 쌍의 구조를 가지며, 키는 중복될 수 있다. x
Map 인터페이스는 순서를 유지하지 않는다. o
Map 인터페이스의 구현체 중 하나인 HashMap은 동기화를 보장한다. x
Map 인터페이스에서 일반적으로 null 키와 null 값은 허용되지 않는다. x
 - Map 인터페이스는 허용한다.
 - Hashtable은 null 키나 값이 허용되지 않으며, TreeMap도 null 키를 허용하지 않음

4. 다음 중, 옳은 설명을 모두 고르세요.

Stack은 FIFO 원칙에 따라, Queue는 LIFO 원칙에 따라 항목을 추가하고 제거한다. x
 - Stack: LIFO
 - Queue: FIFO
Stack과 Queue는 모두 Deque 인터페이스로 구현할 수 있다. o
Stack 클래스의 push() 메서드는 Stack의 맨 아래에 요소를 추가한다. x
 - 맨 위
Queue 인터페이스의 offer() 메서드는 Queue의 가장 뒤에 항목을 추가한다. o
Stack과 Queue 모두 단일 스레드 환경에서만 사용되어야 한다. x
 - 멀티 스레드에서도 사용 가능

5. 다음 중, ArrayList에서 가장 시간이 많이 드는 작업은? (단, 작업 도중에 ArrayList의 크기 변경이 발생하지 않는다고 가정한다)
 - List는 순서를 유지하기 때문에
 - 첫 번째 요소를 추가하려면 그 뒤의 요소를 모두 바꿔야한다.
마지막에 새로운 요소를 추가
첫 번째에 요소를 추가 o
중간에 새로운 요소를 추가
마지막 요소를 삭제