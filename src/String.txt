---- String 클래스 ----
 - String은 int, boolean 같은 기본형이 아닌 참조형이다.

** String을 사용하여 문자열을 생성하는 방법
1. 쌍따옴표 사용: "hello"
 - 편의상 쌍따옴표로 감싸서 사용하면 자바에서 아래의 객체 생성 형식으로 변경해준다.
2. 객체 생성: new String("hello");

** String 클래스의 실제 문자열 값은 char[]에 보관된다.
 - String 클래스 내부의 private final char[] value;
 - 자바 9 이전은 char[] 이후에는 byte[]를 사용한다.

---- String 클래스의 메소드 ----
** 물론 String 클래스의 기능은 방대하므로 주요 메소드만 소개
1. length(): 문자열의 길이를 반환
2. charAt(int index): 특정 인덱스의 문자를 반환
3. substring(int beginIndex, int endIndex): 문자열의 부분 문자열을 반환
4. indexOf(String str): 특정 문자열이 시작되는 인덱스를 반환
5. toLowerCase(), toUpperCase(): 문자열을 소문자 또는 대문자로 반환
6. trim(): 문자열 양 끝의 공백을 제거한다.
7. concat(String str): 문자열을 더한다.

---- String 클래스와 참조형 ----
** String 클래스는 참조형이기 때문에 원칙적으로는 '+' 연산을 사용할 수 없다.
   하지만 너무 자주 다루어지기 때문에 자바에서 편의상 '+'제공한다.

---- String 클래스의 비교 ----
** String 클래스를 비교할 때는 '==' 가 아니라 항상 equals()로 비교해야한다.
 - String 클래스 내부에는 문자열 값을 비교할 수 있도록 equals()가 오버라이딩 되어 있기 때문에
   Object 클래스의 equals()를 사용하지 않는다.
 - 메소드로 문자열을 비교하는 경우 매개변수로 넘어오는 String 객체가 new String()으로 만들어진 것인지,
   리터럴이 넘어오는 것인지 확인할 수 없다. 따라서 문자열 비교는 항상 equals()를 사용하여 동등성 비교를 해야 한다.

!! 문자열 리터럴, 문자열 풀
 - 자바는 문자열 리터럴을 사용하는 경우 메모리 효율성과 성능 최적화를 위해
   문자열 풀을 사용한다.
   - 같은 value의 문자열 리터럴이 있다면 실행되는 시점에서 문자열 풀을 새로 생성하지 않고
     문자열 풀에 이미 있는 것에 넣어준다.
   - 문자열 리터럴을 사용한다면 서로 다른 변수여도 값이 같다면 같은 객체를 가진다.

---- String 클래스 - 불변 객체 ----
** String 클래스는 불변 객체이다.
 - 따라서 생성 이후에 절대로 내부의 문자열 값을 변경할 수 없다.
   (내부적으로 final 키워드로 이루어져 있다.)

** String 클래스가 불변으로 설계된 이유
 - 문자열 풀에 있는 String 인스턴스의 값이 중간에 변경되면
   같은 문자열을 참조하는 다른 변수의 값이 모두 같이 변경되어 버린다.

---- 가변 String ----
 - String 클래스의 단점
   - String 클래스는 기본적으로 불변이다.
   - 문자를 더하거나 변경할 때마다 계속해서 새로운 객체를 생성해야 한다.
** StringBuilder **
 - 불변 String 해결을 위한 가변 String
 - String 클래스와는 다르게 내부에 final 키워드가 붙어 있지 않다.
 - StringBuilder 객체 안에서 문자열을 추가, 삭제, 수정할 수 있고
   이때 새로운 객체가 생성되지 않는다.
 - 메모리 사용을 줄이고 성능을 향상시킬 수 있다.
!! 작업이 완료됬다면 다시 String 클래스로 변환시켜 불변으로 해두는 것이 좋다.

---- String 최적화 ----
1. 자바 컴파일러는 컴파일 시점에 문자열 리터럴을 더하는 부분을 자동으로 합쳐준다.
2. String을 사용한 변수 값과 같은 경우는 아래와 같은 방식으로 최적화 한다.
   String result = new StringBuilder().append(str1).append(str2).toString();
3. 문자열을 루프안에서 더하는 경우에는 최적화가 이루어지지 않는다.
 - 루프 내에서는 최적화가 되는 것처럼 보이지만 반복 횟수만큼 String 객체를 생성해야하기 때문
 - 이럴때는 StringBuilder를 사용하는 것이 좋다.

** StringBuilder를 사용하는 것이 좋은 경우 **
1. 반복문에서 반복해서 문자를 연결할 때
2. 조건문을 통해 동적으로 문자열을 조합할 때
3. 복잡한 문자열의 특정 부분을 변경해야 할 때
4. 매우 긴대용량 문자열을 다룰 때
참고: StringBuffer
 - 내부에 동기화가 되어 있으므로, 멀티 스레드 상황에 안전하지만
   동기화 오버헤드로 인해 성능이 느리다.

!! StringBuilder 클래스는 메소드 체이닝 기법을 제공한다.
public StringBuilder append(String str) {
    super.append(str);
    return this;
}








